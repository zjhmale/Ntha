;; example1

(data Ast
  (Num Number)
  (Add Ast Ast)
  (Sub Ast Ast)
  (Mul Ast Ast)
  (Div Ast Ast))

(ƒ eval [n]
  (match n
    ((Num a) ⇒ a)
    ((Add a b) ⇒ (+ (eval a) (eval b)))
    ((Sub a b) ⇒ (- (eval a) (eval b)))
    ((Mul a b) ⇒ (* (eval a) (eval b)))
    ((Div a b) ⇒ (/ (eval a) (eval b)))))

(let sym (Mul (Add (Num 4) (Num 3)) (Sub (Num 4) (Num 1))))

(let result (eval sym))

;; example2

(data Oper Add Sub)
(data Expr
  (Num Number)
  (App Oper Expr Expr))

(let a (App Add (Num 5) (Num 6)))

(ƒ eval [e]
  (match e
    ((Num n) ⇒ n)
    ((App o e1 e2) ⇒
      (match o
        (Add ⇒ (+ (eval e1) (eval e2)))
        (Sub ⇒ (- (eval e1) (eval e2)))))))

(let av (eval a))

(ƒ eval [e]
  (match e
    ((Num n) ⇒ n)
    ((App Add e1 e2) ⇒ (+ (eval e1) (eval e2)))
    ((App Sub e1 e2) ⇒ (- (eval e1) (eval e2)))))

(let av (eval a))

(ƒ simplify [e]
  (match e
    ((App Add (Num n) e2) ⇒ (if (= n 0) e2 e))))

(let a (App Add (Num 0) (Num 6)))
(let b (simplify a))

;; example3

(data Op Add Sub Mul Div)

(data Expr
  (Num Number)
  (Var String)
  (Let [Char] Expr Expr)
  (Binop Op (Expr . Expr)))

(let op-map {:add +
             :sub -
             :mul *
             :div /})

(ƒ do-eval [fn (v1 . v2)]
  (Just (+ v1 v2)))

(let eval-op
  (λ op v1 v2 ⇒
    (match (v1 . v2)
      (((Just v1) . (Just v2)) ⇒
        (match op
          (Add ⇒ (do-eval (:add op-map) (v1 . v2)))
          (Sub ⇒ (do-eval (:sub op-map) (v1 . v2)))
          (Mul ⇒ (do-eval (:mul op-map) (v1 . v2)))
          (Div ⇒ (do-eval (:div op-map) (v1 . v2)))))
      (_ ⇒ Nothing))))

(ƒ eval [env expr]
  (match expr
    ((Num i) ⇒ (Just i))
    ((Var x) ⇒ (lookup x env))
    ((Let x e1 in-e2) ⇒ (let [val-x (eval env e1)]
                           (match val-x
                             ((Just v) ⇒ (eval ((x . v) :: env) in-e2))
                             (_ ⇒ Nothing))))
    ((Binop op (e1 . e2)) => (let [v1 (eval env e1)
                                   v2 (eval env e2)]
                               (eval-op op v1 v2)))))

(eval [] (Let "x" (Num 1) (Binop Add ((Var "x") . (Var "x")))))
