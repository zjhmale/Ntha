(data Maybe a (Just a) Nothing)

(monad Maybe {:return (λ x → (Just x))
              :>>= (λ x f → (match x
                              ((Just v) → (f v))
                              (Nothing → Nothing)))})

(ƒ len [l]
  (match l
    ([] ⇒ 0)
    (_ :: t ⇒ (+ 1 (len t)))))

(ƒ map [f xs]
  (match xs
    ([] ⇒ [])
    (h :: t ⇒ ((f h) :: (map f t)))))

(ƒ fold [f s xs]
  (match xs
    ([] ⇒ s)
    (h :: t ⇒ (fold f (f s h) t))))

(ƒ filter [f xs]
  (match xs
    ([] ⇒ [])
    (h :: t ⇒ (if (f h)
                 (h :: (filter f t))
                 (filter f t)))))

(ƒ range [x y]
  (let [rec-range (λ x y res ⇒ (if (> x y)
                                  res
                                  (rec-range x (- y 1) (y :: res))))]
    (rec-range x y [])))

(ƒ lookup [name pairs]
  (match pairs
    ([] ⇒ Nothing)
    ((k . v) :: t ⇒ (if (= name k)
                      (Just v)
                      (lookup name t)))))

(ƒ conj [e l]
  (reverse (e :: (reverse l))))

(ƒ concat [l1 l2]
  (match l2
    ([] → l1)
    (h :: t → (concat (conj h l1) t))))

(asserteq (concat [1 2 3] [4 5 6]) [1 2 3 4 5 6])
(asserteq (concat "123" "456") "123456")

(ƒ flatten [l]
  (match l
    ([] → [])
    (h :: t → (concat h (flatten t)))))

(asserteq (flatten [[1] [2] [3]]) [1 2 3])

(ƒ empty? [l]
  (match l
    ([] → true)
    (_ → false)))

(asserteq (empty? []) true)
(asserteq (empty? [3]) false)

(ƒ head [l]
  (match l
    ([] → (error "empty list"))
    (h :: _ → h)))

(asserteq (head [1 2 3]) 1)

(ƒ tail [l]
  (match l
    ([] → [])
    (_ :: t → t)))

(asserteq (tail [1 2 3]) [2 3])

(ƒ max [a b] (if (≥ a b) a b))
